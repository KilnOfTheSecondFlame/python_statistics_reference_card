\documentclass[14pt]{article}

\usepackage[a4paper,left=1cm,right=1cm,top=15mm,bottom=1cm,headsep=5mm,landscape]{geometry}
\usepackage[latin1]{inputenc}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{multicol}
\usepackage{lipsum}
\usepackage{minted}
\usepackage{xcolor}
\usepackage{fancyhdr}

\definecolor{headertext}{rgb}{0.5,0.5,0.5}
\renewcommand{\headrulewidth}{0pt}
\pagestyle{fancy}
\fancyhf{}
\lhead{\color{headertext} PYTHON - REFERENZKARTE}
\chead{\color{headertext} STATISTICS FOR DATA SCIENCE}
\rhead{\color{headertext} SEITE \thepage}

\setlength{\parindent}{0cm}
\newminted[python]{python}{}
\newmintinline{python}{breaklines,tabsize=2}

\begin{document}
\begin{multicols*}{3}

\subsection*{Häufig verwendete Bibliotheken}
\begin{python}
import matplotlib.pyplot as plt
import scipy.stats as st
import seaborn as sns
import pandas as pd
import numpy as np
\end{python}

\subsection*{Numpy Basics}
\pythoninline{np.e}: Konstante mit Wert von $e$ \\
\pythoninline{np.pi}:  Konstante mit Wert von $\pi$ \\
\pythoninline{np.sqrt(2)}: Wurzel von Zahl berechnen \\
\pythoninline{np.square(2)}: Quadrat von Zahl berechen \\
\pythoninline{np.abs(-45)}: Absolutwert einer Zahl berechnen \\
\pythoninline{np.round(2.35, x)}: Zahl auf \textit{x} Nachkomastellen runden \\
\pythoninline{np.log(100)}: Natürlicher Logarithmus berechnen \\
\pythoninline{np.log10(100)}: Logarithmus mit Basis 10 berechnen

\subsection*{Numpy Arrays}
\pythoninline{arr = np.array([2, 1, 4, 5, -8, 10])} \\
Numpy-Array erzeugen \\

\pythoninline{np.linspace(start=1, stop=2, num=4)} \\
\textit{num} Zahlen zwischen \textit{start} und \textit{stop} \\
In diesem Beispiel: [1.0, 1.333, 1.666, 2.0] \\

\pythoninline{np.arange(start=1, stop=4, step=.6)} \\
Zahlen von \textit{start} bis \textit{stop} mit inkrement \textit{step} \\
In diesem Beispiel: [1.0, 1.6, 2.2, 2.8, 3.4] \\

\pythoninline{new_arr = arr.reshape((n, m))} \\
1-dimensionales Array in 2-dimensionales umwandeln \\
Neues Array hat \textit{n} Zeilen mit je \textit{m} Elementen \\

\pythoninline{arr = np.random.choice(arr, size=1000)} \\
Neues Array mit der Grösse \textit{size} erstellen und zufällig \\
mit Werten aus dem übergebenen Array befüllen \\

\pythoninline{arr = np.arange(1, 25)} \\
\pythoninline{np.random.choice(arr, 24, replace=False)} \\
Zahlen zufällig sortieren \\
In diesem Beispiel die Zahlen 1 bis 24 \\

\pythoninline{np.percentile(arr, q=[2.5, 97.5])} \\
Werte der Quantile eines Datensatz anzeigen \\
In diesem Beispiel die 2.5\%- und 97.5\%-Quantile \\

\pythoninline{np.sum(arr > x)} \\
Werte grösser als \textit{x} in einem Array zählen \\

\pythoninline{np.tile(arr, x)} \\
Array \textit{x}-Mal wiederholen und aneinander hängen \\

\pythoninline{np.repeat(["M1","M2","M3"], [x1, x2, x3])} \\
Jeder Werte des Array mit Index $i$, $x_i$-mal wiederholen \\

\pythoninline{np.corrcoef(arr_x, arr_y)} \\
Korrelationsmatrix berechnen

\subsection*{Pandas Series}
\begin{python}
series = pd.Series([79.98, 80.04, 80.02])
series = pd.Series(
  [1, 5, 9, 15, 20],
  index=("mo", "di", "mi", "do", "fr")
)
\end{python}

\pythoninline{series.sum()}: Die Summe der Elemente von \textit{series} \\
\pythoninline{series.mean()}: Der Durchschnitt der Elemente von \textit{series} \\
\pythoninline{series.median()}: Der Median der Elemente von \textit{series} \\
\pythoninline{series.var()}: Die Varianz der Elemente von \textit{series} \\
\pythoninline{series.std()}: Standardabweichung von \textit{series} \\
\pythoninline{series.count()}: Anzahl Elemente der \textit{series} \\
\pythoninline{series.round(x)}: Werte auf \textit{x} Nachkomastellen runden \\
\pythoninline{series.index}: Zeilenbeschrift der Elemente von \textit{series} \\
\pythoninline{series.size}: Die Anzahl der Elemente von \textit{series} \\
\pythoninline{series[1]}: Zugriff auf ein Elemente via Index \\
\pythoninline{series["mi"]}: Zugriff via Zeilenbeschrift \\

\pythoninline{series.hist(bins=[0, 1, 10, 11, 12])} \\
Histogramm mit angegebenen Klassengrenzen plotten 

\subsection*{Quantile und Quartilsdifferenz}
\pythoninline{series.quantile(q=0.25, interpolation="midpoint")}
Quantile (z.B. 25\%, 75\%, \dots) von \textit{series} berechnen \\

\pythoninline{q75, q25 = series.quantile(q = [.75, .25], }\\
\pythoninline{	interpolation="midpoint")} \\
\pythoninline{iqr = q75 - q25} \\
Quartilsdifferenz von series berechnen

\subsection*{Werte einlesen}
\pythoninline{np.loadtxt(r"./data.txt")} \\
Daten für ein Array aus einem Textfile laden \\

\pythoninline{frame = pd.read_csv(r"./data.csv", } \\
\pythoninline{	sep=",", index_col=0)} \\
Werte für eine Frame aus einem CSV auslesen \\

\pythoninline{pd.read_table(r"./gamma.txt", } \\
\pythoninline{	delim_whitespace=True)} \\
leerzeichengetrennte Daten einlesen mit Pandas

\subsection*{Pandas DataFrame}
\begin{python}
frame = pd.DataFrame({
  "Luzern": ([1, 5, 9, 15, 20]),
  "Basel": ([3, 4, 12, 16, 18]),
  "Zuerich": ([8, 6, 10, 17, 23])
  }, index=["jan", "feb", "mar", "apr", "mai"]
)
\end{python}

\pythoninline{frame.columns}: Spaltenname auslesen \\ 
\pythoninline{frame.shape}: Anzahl Zeilen und Spalten des Frames \\
\pythoninline{frame.T}: Zeilen und Spalten vertauschen \\ 
\pythoninline{frame.describe()}: Kennzahlen jeder Spalte anzeigen \\
\pythoninline{frame.mean(axis=0)}: Durchschnitt pro Spalte berechnen \\ 
\pythoninline{frame.mean(axis=1)}: Durchschnitt pro Zeile berechnen \\
\pythoninline{frame.head(n)}: Erste \textit{n} Zeilen des Frames anzeigen \\
\pythoninline{frame.tail(n)}: Letzte \textit{n} Zeilen des Frames anzeigen \\
\pythoninline{frame.drop(x, 0)}: Zeile mit dem Index \textit{x} löschen \\
\pythoninline{frame.drop(x, 1)}: Spalte \textit{x} löschen \\
\pythoninline{frame.corr()}: Korrelationsmatrix berechnen \\

\pythoninline{frame.loc["mar":"mai","Luzern"]} \\
Auf einen Bereiche in einem DataFrame zugreifen \\

\pythoninline{frame.loc[["mar","mai"],["Basel","Zuerich"]]} \\
Auf ausgewählt Elemente in einem DataFrame zugreifen

\subsection*{DataFrame filtern}
\pythoninline{frame.sort_values(by='Luzern', ascending=False)} \\
Daten im Frame nach einer Spalte sortieren \\

\pythoninline{frame.nsmallest(n, 'Luzern')} \\
\pythoninline{frame.nlargest(n, 'Luzern')} \\
Daten im Frame nach einer Spalte sortieren und dann \\ 
\textit{n} Zeilen mit grösstem oder kleinstem Werte zurückgeben \\

\pythoninline{mean = frame.mean()['Luzern']} \\
\pythoninline{frame.loc[frame['Luzern'] < mean, :]} \\
Daten anhand des Wertes einer Spalte filtern

\subsection*{Matplotlib PyPlot}
\pythoninline{plt.title("...")}: Titel des Plots festlegen \\
\pythoninline{plt.xlabel("...")}: X-Achsenbeschriftung festlegen \\
\pythoninline{plt.ylabel("...")}: Y-Achsenbeschriftung festlegen \\
\pythoninline{plt.show()}: Plot anzeigen \\

\pythoninline{plt.subplot(2, 3, 4)} oder \pythoninline{plt.subplot(234)} \\
Sub-Plot mit 2 Zeilen und 3 Spalten erstellen und den \\ 
nächsten Plot an der Position 4 einfügen. Die Position wird \\
von links nach rechts und dann von oben nach unten gezählt

\subsection*{Plots erstellen}
\pythoninline{series.plot(kind="hist", edgecolor="black")} \\
Histogramm erstellen und Balken mit Farbe umrahmen \\

\pythoninline{series.plot(kind="hist", normed=True, ...)}
Normiertes Histogramm erstellen \\

\pythoninline{series.plot(kind="hist", bins=20, ...)} \\
Anzahl Klassen des Histogramm manuell festlegen \\

\pythoninline{series.plot(kind='hist', cumulative=True, 
	histtype='step', normed=True)} \\
Empirische kumulative Verteilungsfunktion plotten \\

\pythoninline{series.plot(kind='box', title='Methode A')} \\
Boxplot von \textit{series} erstellen und Titel des Plots festlegen \\

\pythoninline{frame.plot(kind='scatter', x='wine', y='mor')} \\
Streudiagramm mit zwei ausgewählten Achsen erstellen \\
Parameter \textit{x} und \textit{y} müssen auf Indizes des \textit{frame} verweisen \\

\pythoninline{b, a = np.polyfit(x_series, y_series, deg=1)} \\
\pythoninline{x = np.linspace(x_series.min(), x_series.max())} \\
\pythoninline{plt.plot(x, a + b * x, c='orange')} \\
Plotten einer Regressionsgerade, bei welcher die Daten \\
einem Polynom ersten Grades angeglichen wurden \\

\pythoninline{st.probplot(arr, plot=plt)} \\
QQ-Plot anhand einer Normalverteilung \\

\pythoninline{plt.hist(series.T, bins=20, density=True)} \\
Plotten eines Histograms mit der Fläche 1

\subsection*{Verteilungen}
\pythoninline{cdf}: $P(X \leq x)$ \\
\pythoninline{ppf}: Quantile der Verteilung \\
\pythoninline{pdf}: Dichte an der Stelle $x$ \\
\pythoninline{rvs}: $size$ Zufallszahlen generieren \\

\pythoninline{st.uniform.cdf(x=1, loc=0, scale=7)} \\
$P(X \leq 1)$ falls $X \sim Unif(0, 7)$ \\

\pythoninline{st.uniform.pdf(x=1, loc=0, scale=7)} \\
Dichte an der Stelle \textit{x} = 3 falls $X \sim Unif(0, 7)$ \\

\pythoninline{st.uniform.rvs(size=3, loc=0, scale=7)} \\
uniform verteilte Zufallszahlen, $X_i \sim Unif(0, 7)$ \\

\pythoninline{st.expon.cdf(x=4, loc=0, scale=1/3)} \\
$P(X \leq 4)$ falls $X \sim Exp(3)$ \\

\pythoninline{st.expon.pdf(x=1, loc=0, scale=1/3)} \\
Dichte an der Stelle \textit{x} = 1 falls $X \sim Exp(3)$ \\

\pythoninline{st.norm.cdf(x=130, loc=100, scale=15)} \\
$P(X \leq 130)$ falls $X \sim \mathcal{N}(100, 15^2)$ \\

\pythoninline{st.norm.ppf(q=0.05, loc=100, scale=15)} \\
Quantile einer Normalverteilung \\

\pythoninline{st.norm.cdf(x=1.5)} \\
Standardnormalverteilung \\

\pythoninline{st.binom.cdf(k=5100, n=10000, p=0.5)} \\
$P(X \leq 5100)$ falls $X \sim Bin(10000, 0.5)$ \\

\pythoninline{st.t.cdf(x=168, df=149, loc=164, } \\
\pythoninline{	scale=10/np.sqrt(150))} \\
$P[\overline{X}_{150} \leq 168]$ falls $u = 164$, $\hat{o} = 10$ und $T \sim t_{149}$ \\

\pythoninline{st.t.ppf(0.05, df=v)} \\
Quantile einer T-Verteilung mit \textit{v} Freiheitsgrade \\

\pythoninline{st.norm.rvs(size=n)}\\
generiert \textit{n} normalverteilte Zahlen \\

\pythoninline{st.t.rvs(size=n, df=v)} \\
generiert \textit{n} t-verteilte Zahlen mit \textit{v} Freiheitsgrade \\

\pythoninline{st.chi2.rvs(size=n, df=v)} \\
generiert \textit{n} chi-verteilte Zahlen mit \textit{v} Freiheitsgrade

\subsection*{Integral berechnen}
\pythoninline{from scipy.integrate import quad} \\
\pythoninline{f = lambda x: x * (15 - x/4)} \\
\pythoninline{ans, _ = quad(f, 0, 60)} \\
In diesem Fall das Integral: $\int_{0}^{60} x * (15 - \frac{x}{4})$

\subsection*{Vertrauensintervall}
\pythoninline{st.t.interval(alpha=0.95, df=12, loc=80.02, } \\
\pythoninline{	scale=0.024/np.sqrt(13))} \\
95\% Vertrauensintervall einer t-Verteilung \\

\pythoninline{st.norm.interval(alpha=0.99, loc=31, } \\
\pythoninline{	scale=6/np.sqrt(10))} \\
99\% Vertrauensintervall einer Normalverteilung

\subsection*{Statistische Tests}
\pythoninline{st.binom_test(x=3, n=5, p=0.5)} \\
Vorzeichentest mit \textit{x} Erfolge bei \textit{n} Versuchen \\

\pythoninline{st.wilcoxon(arr, correction=True)} \\
Wilcoxon-Test \\

\pythoninline{st.ttest_rel(series1, series2)} \\
Statistischer Test für gepaarte Stichproben  \\

\pythoninline{st.ttest_ind(x, y, equal_var=False)} \\
Statistischer Test für ungepaarte Stichproben  \\

\pythoninline{st.mannwhitneyu(x, y)} \\
Mann-Whitney U-Test (aka Wilcoxon Rank-sum Test) \\

\pythoninline{st.ttest_1samp(series, 1).pvalue} \\
P-Wert eines T-Tests für eine Series berechnen

\subsection*{Varianzanalyse}
\pythoninline{from statsmodels.graphics.factorplots} \\
\pythoninline{	import interaction_plot} \\
\pythoninline{from statsmodels.stats.anova import anova_lm} \\
\pythoninline{from statsmodels.formula.api import ols} \\
\pythoninline{from patsy.contrasts import Sum} \\
Benötigte Bibliotheksfunktionen für Varianzanalysen \\

\pythoninline{sns.stripplot(x="...", y="...", data=frame)} \\
Varianz-Analyse mit Stripcharts zwischen \textit{x} und \textit{y} \\

\pythoninline{sns.boxplot(x="...", y="...", data=frame)} \\
Varianz-Analyse mit Boxplots zwischen \textit{x} und \textit{y} \\

\pythoninline{sns.distplot(Fstat, kde=False, norm_hist=True, 
	hist_kws=dict(edgecolor="black", 
	linewidth=2))} \\
F-Statistik plotten \\
 
\pythoninline{fit = ols("steak_id~Treatment", data=frame).fit()} \\
\pythoninline{fit.summary()} \\
Gruppenmittelmodell berechnen \\

\pythoninline{fit_pred = fit.get_prediction()} \\
\pythoninline{fit_pred.conf_int()} \\
Vertrauensintervalle für Gruppenmittelwerte \\

\pythoninline{interaction_plot(x=frame["Batch"], }\\
\pythoninline{	trace=frame["Methode"], response=frame["Y"])} \\
Interaktionsplot erstellen \\
- entlang der y-Achse die Zielgrösse (response) \\
- entlang der x-Achse der durch x festgelegte Faktor \\
- für jede Stufe in trace wird dann eine Linie gezogen \\

\pythoninline{fit = ols("steak_id~Treatment", data=frame).fit()} \\
\pythoninline{anova_lm(fit)} \\
Anova Tabelle berechnen \\

\pythoninline{formula = "Y ~ C(Methode, Sum) + C(Batch, Sum)"} \\
\pythoninline{fit = ols(formula, data=frame).fit()} \\
Zweiweg-Varianzanalyse mit Blöcken \\

\pythoninline{formula = "Y ~ C(Konz,Sum) * C(Temp,Sum)"} \\
\pythoninline{fit = ols(formula, data=frame).fit()} \\
Faktorielle Experimente mit zwei Faktoren

\end{multicols*}
\end{document}

