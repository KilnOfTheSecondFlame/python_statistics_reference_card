\documentclass[14pt]{article}

\usepackage[a4paper,left=1cm,right=1cm,top=15mm,bottom=1cm,headsep=5mm,landscape]{geometry}
\usepackage[latin1]{inputenc}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{multicol}
\usepackage{lipsum}
\usepackage{minted}
\usepackage{xcolor}
\usepackage{fancyhdr}

\definecolor{headertext}{rgb}{0.5,0.5,0.5}
\renewcommand{\headrulewidth}{0pt}
\pagestyle{fancy}
\fancyhf{}
\lhead{\color{headertext} PYTHON - REFERENZKARTE}
\chead{\color{headertext} STATISTICS FOR DATA SCIENCE}
\rhead{\color{headertext} SEITE \thepage}

\setlength{\parindent}{0cm}
\newminted[python]{python}{}
\newmintinline{python}{breaklines}

\begin{document}
\begin{multicols*}{3}

\subsection*{Bibliotheken}
\begin{python}
import matplotlib.pyplot as plt
import scipy.stats as st
import pandas as pd
import numpy as np
\end{python}

\subsection*{Numpy Basics}
\pythoninline{np.e}: Konstante mit Wert von $e$ \\
\pythoninline{np.pi}:  Konstante mit Wert von $\pi$ \\
\pythoninline{np.sqrt(2)}: Wurzel von Zahl berechnen \\
\pythoninline{np.square(2)}: Quadrat von Zahl berechen \\
\pythoninline{np.abs(-45)}: Absolutwert einer Zahl berechnen \\
\pythoninline{np.round(2.35, 1)}: Zahl auf x Nachkomastellen runden \\
\pythoninline{np.corrcoef(x, y)}: Korrelationsmatrix berechnen \\
\pythoninline{np.log(100)}: Natürlicher Logarithmus berechnen \\
\pythoninline{np.log10(100)}: Logarithmus mit Basis 10 berechnen

\subsection*{Numpy Arrays}
\begin{python}
arr = np.array([2, 1, 4, 5, -8, 10])
\end{python}

\pythoninline{3*arr}: Jede Array-Komponent mit Zahl multiplizieren \\

\pythoninline{np.linspace(start=1, stop=2, num=4)} \\
num Zahlen zwischen start und stop \\
In diesem Beispiel: [1.0, 1.333, 1.666, 2.0] \\

\pythoninline{np.arange(start=1, stop=4, step=.6)} \\
Zahlen von start bis stop mit inkrement step\\
In diesem Beispiel: [1.0, 1.6, 2.2, 2.8, 3.4] \\

\pythoninline{new_arr = arr.reshape((n, m))} \\
1-dimensionales Array in 2-dimensionales umwandeln \\
Neues Array hat n Zeilen mit je m Elementen \\

\pythoninline{new_arr = np.random.choice(arr, size=1000)} \\
Neues Array mit der Grösse size erstellen und zufällig \\
mit Werten aus dem übergebenen Array befüllen \\

\pythoninline{np.percentile(arr, q=[2.5, 97.5])} \\
Werte der Quantile eines Datensatz anzeigen \\

\pythoninline{np.sum(arr > 0)} \\
Werte grösser als x in einem Array zählen

\subsection*{Pandas Series}
\begin{python}
series = pd.Series([79.98, 80.04, 80.02])
series = pd.Series(
  [1, 5, 9, 15, 20],
  index=("mo", "di", "mi", "do", "fr")
)
\end{python}

\pythoninline{series.sum()}: Die Summe der Elemente von series \\
\pythoninline{series.mean()}: Der Durchschnitt der Elemente von series \\
\pythoninline{series.median()}: Der Median der Elemente von series \\
\pythoninline{series.var()}: Die Varianz der Elemente von series \\
\pythoninline{series.std()}: Standardabweichung von series \\
\pythoninline{series.count()}: Anzahl Elemente der series \\
\pythoninline{series.round(0)}: Werte auf x Nachkomastellen runden \\
\pythoninline{series.index}: Zeilenbeschrift der Elemente von series \\
\pythoninline{series.size}: Die Anzahl der Elemente von series \\
\pythoninline{series[1]}: Zugriff auf ein Elemente via Index \\
\pythoninline{series["mi"]}: Zugriff via Zeilenbeschrift \\

\pythoninline{series.hist(bins=[0,1,10,11,12])} \\
Histogramm mit angegebenen Klassengrenzen plotten 

\subsection*{Quantile und Quartilsdifferenz}
\pythoninline{series.quantile(q=0.25, interpolation="midpoint")}
Quantile (z.B. 25\%, 75\%, \dots) von series \\

\pythoninline{q75, q25 = series.quantile(q = [.75, .25], 
	interpolation="midpoint")} \\
\pythoninline{iqr = q75 - q25} \\
Quartilsdifferenz von series berechnen

\subsection*{Werte einlesen}
\pythoninline{np.loadtxt(r"./data.txt")} \\
Daten für ein Array aus einem Textfile laden \\

\pythoninline{frame = pd.read_csv(r"./data.csv", sep=",", 
	index_col=0)} \\
Werte für eine Frame aus einem CSV auslesen 

\subsection*{Pandas DataFrame}
\begin{python}
frame = pd.DataFrame({
  "Luzern": ([1, 5, 9, 15, 20]),
  "Basel": ([3, 4, 12, 16, 18]),
  "Zuerich": ([8, 6, 10, 17, 23])
  }, index=["jan", "feb", "mar", "apr", "mai"]
)
\end{python}

\pythoninline{frame.columns}: Spaltenname auslesen \\ 
\pythoninline{frame.shape}: Anzahl Zeilen und Spalten des Frames \\
\pythoninline{frame.T}: Zeilen und Spalten vertauschen \\ 
\pythoninline{frame.describe()}: Kennzahlen jeder Spalte anzeigen \\
\pythoninline{frame.mean(axis=0)}: Durchschnitt pro Spalte berechnen \\ 
\pythoninline{frame.mean(axis=1)}: Durchschnitt pro Zeile berechnen \\
\pythoninline{frame.head(5)}: Erste n Zeilen des Frames anzeigen \\
\pythoninline{frame.tail(5)}: Letzte n Zeilen des Frames anzeigen \\
\pythoninline{frame.drop('mar', 0)}: Zeile mit dem Index xy löschen \\
\pythoninline{frame.drop('Luzern', 1)}: Spalte xy löschen \\
\pythoninline{frame.corr()}: Korrelationsmatrix berechnen \\

\pythoninline{frame.loc["mar":"mai","Luzern"]} \\
Auf einen Bereiche in einem DataFrame zugreifen \\

\pythoninline{frame.loc[["mar","mai"],["Basel","Zuerich"]]} \\
Auf ausgewählt Elemente in einem DataFrame zugreifen

\subsection*{DataFrame filtern}
\pythoninline{frame.sort_values(by='Luzern', ascending=False)} \\
Daten im Frame nach einer Spalte sortieren \\

\pythoninline{frame.nsmallest(1, 'Luzern')} \\
\pythoninline{frame.nlargest(1, 'Luzern')} \\
Daten im Frame nach einer Spalte sortieren und dann \\ 
n Zeilen mit grösstem oder kleinstem Werte zurückgeben \\

\pythoninline{mean = frame.mean()['Luzern']} \\
\pythoninline{frame.loc[frame['Luzern'] < mean, :]} \\
Daten anhand des Wertes einer Spalte filtern

\subsection*{Matplotlib PyPlot}
\pythoninline{plt.title("...")}: Titel des Plots festlegen \\
\pythoninline{plt.xlabel("...")}: X-Achsenbeschriftung festlegen \\
\pythoninline{plt.ylabel("...")}: Y-Achsenbeschriftung festlegen \\
\pythoninline{plt.show()}: Plot anzeigen \\

\pythoninline{plt.subplot(2, 3, 4)} oder \pythoninline{plt.subplot(234)} \\
Sub-Plot mit 2 Zeilen und 3 Spalten erstellen und den \\ 
nächsten Plot an der Position 4 einfügen. Die Position wird \\
von links nach rechts und dann von oben nach unten gezählt

\subsection*{Plots erstellen}
\pythoninline{series.plot(kind="hist", edgecolor="black")} \\
Histogramm erstellen und Blaken mit Farbe umrahmen \\

\pythoninline{series.plot(kind="hist", normed=True, ...)}
Normiertes Histogramm erstellen \\

\pythoninline{series.plot(kind="hist", bins=20, ...)} \\
Anzahl Klassen des Histogramm manuell festlegen \\

\pythoninline{series.plot(kind='hist', cumulative=True, 
	histtype='step', normed=True)} \\
Empirische kumulative Verteilungsfunktion plotten \\

\pythoninline{series.plot(kind='box', title='Methode A')} \\
Boxplot von series erstellen und Titel des Plots festlegen \\

\pythoninline{series.plot(kind='scatter', x='wine', y='mor')} \\
Streudiagramm mit zwei ausgewählten Achsen erstellen \\
Parameter x und y müssen auf Indizes der series verweisen \\

\pythoninline{b, a = np.polyfit(x_series, y_series, deg=1)} \\
\pythoninline{x = np.linspace(x_series.min(), x_series.max())} \\
\pythoninline{plt.plot(x, a + b * x, c='orange')} \\
Plotten einer Regressionsgerade, bei welcher die Daten \\
einem Polynom ersten Grades angeglichen wurden \\

\pythoninline{arr = np.array([24.4, 27.6, 27.8, 27.9, ...])} \\
\pythoninline{st.probplot(arr, plot=plt)} \\
QQ-Plot anhand einer Normalverteilung \\

\pythoninline{plt.hist(series.T, bins=20, density=True)} \\
Plotten eines Histograms mit der Fläche 1 unter den Balken

\subsection*{Verteilungen}
\pythoninline{st.uniform.cdf(x=1, loc=0, scale=7)} \\
$P(X \leq 1)$ falls $X \sim Unif(0, 7)$ \\

\pythoninline{st.uniform.pdf(x=1, loc=0, scale=7)} \\
Dichte an der Stelle x = 3 falls $X \sim Unif(0, 7)$ \\

\pythoninline{st.uniform.rvs(size=3, loc=0, scale=7)} \\
uniform verteilte Zufallszahlen, $X_i \sim Unif(0, 7)$ \\

\pythoninline{st.expon.cdf(x=4, loc=0, scale=1/3)} \\
$P(X \leq 4)$ falls $X \sim Exp(3)$ \\

\pythoninline{st.expon.pdf(x=1, loc=0, scale=1/3)} \\
Dichte an der Stelle x = 1 falls $X \sim Exp(3)$ \\

\pythoninline{st.norm.cdf(x=130, loc=100, scale=15)} \\
$P(X \leq 130)$ falls $X \sim \mathcal{N}(100, 15^2)$ \\

\pythoninline{st.norm.ppf(q=0.05, loc=100, scale=15)} \\
Quantile einer Normalverteilung \\

\pythoninline{st.norm.cdf(x=1.5)} \\
Standardnormalverteilung \\

\pythoninline{st.binom.cdf(k=5100, n=10000, p=0.5)} \\
$P(X \leq 5100)$ falls $X \sim Bin(10000, 0.5)$ \\

\pythoninline{st.t.cdf(x=168, df=149, loc=164, } \\
\pythoninline{	scale=10/np.sqrt(150))} \\
$P[\overline{X}_{150} \leq 168]$ falls $u = 164$, $\hat{o} = 10$ und $T \sim t_{149}$ \\

\pythoninline{st.t.ppf(0.05, df=149)} \\
Quantile einer T-Verteilung mit n Freiheitsgrade \\

\pythoninline{st.norm.rvs(size=n)}\\
generiert n normalverteilte Zahlen \\

\pythoninline{st.t.rvs(size=n, df=v)} \\
generiert n t-verteilte Zahlen mit v Freiheitsgrade \\

\pythoninline{st.chi2.rvs(size=n, df=v)} \\
generiert n chi-verteilte Zahlen mit v Freiheitsgrade

\subsection*{Integral berechnen}
\pythoninline{from scipy.integrate import quad} \\
\pythoninline{f = lambda x: x * (15 - x/4)} \\
\pythoninline{ans, _ = quad(f, 0, 60)} \\
In diesem Fall das Integral: $\int_{0}^{60} x * (15 - \frac{x}{4})$

\subsection*{Vertrauensintervall}
\pythoninline{st.t.interval(alpha=0.95, df=12, loc=80.02, } \\
\pythoninline{	scale=0.024/np.sqrt(13))} \\
95\% Vertrauensintervall einer t-Verteilung \\

\pythoninline{st.norm.interval(alpha=0.99, loc=31, } \\
\pythoninline{	scale=6/np.sqrt(10))} \\
99\% Vertrauensintervall einer Normalverteilung

\subsection*{Statistische Tests}
\pythoninline{st.binom_test(x=3, n=5, p=0.5)} \\
Vorzeichentest \\

\pythoninline{st.wilcoxon(arr, correction=True)} \\
Wilcoxon-Test \\

\pythoninline{st.ttest_rel(series1, series2)} \\
Statistischer Test für gepaarte Stichproben  \\

\pythoninline{st.ttest_ind(x, y, equal_var=False)} \\
Statistischer Test für ungepaarte Stichproben  \\

\pythoninline{st.mannwhitneyu(x, y)} \\
Mann-Whitney U-Test (aka Wilcoxon Rank-sum Test)

\end{multicols*}
\end{document}

